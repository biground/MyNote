# 排序问题

## 目录
- [排序问题](#%e6%8e%92%e5%ba%8f%e9%97%ae%e9%a2%98)
  - [目录](#%e7%9b%ae%e5%bd%95)
  - [插入排序](#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f)
      - [循环不变式的正确性](#%e5%be%aa%e7%8e%af%e4%b8%8d%e5%8f%98%e5%bc%8f%e7%9a%84%e6%ad%a3%e7%a1%ae%e6%80%a7)
      - [在插入排序中的循环不变式](#%e5%9c%a8%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f%e4%b8%ad%e7%9a%84%e5%be%aa%e7%8e%af%e4%b8%8d%e5%8f%98%e5%bc%8f)
      - [插排算法的分析](#%e6%8f%92%e6%8e%92%e7%ae%97%e6%b3%95%e7%9a%84%e5%88%86%e6%9e%90)
  - [归并排序](#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f)
      - [分治法](#%e5%88%86%e6%b2%bb%e6%b3%95)
      - [算法步骤](#%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4)
      - [实现](#%e5%ae%9e%e7%8e%b0)
      - [在归并排序中的循环不变式](#%e5%9c%a8%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%e4%b8%ad%e7%9a%84%e5%be%aa%e7%8e%af%e4%b8%8d%e5%8f%98%e5%bc%8f)
      - [归并排序时间分析](#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%e6%97%b6%e9%97%b4%e5%88%86%e6%9e%90)

**输入:** n个数的一个序列< $a_1$, $a_2$, ..., $a_n$ >。  
**输出:** 输入序列的一个排列< $a'_1$, $a'_2$, ..., $a'_n$>，满足$a'_1$ $\leq$ $a'_2$ $leq$ ... $leq$ $1$。
## 插入排序
> 对于少量元素的排序，这是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时，我们左手为空并且桌上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已经在手中的每一张牌进行比较。**拿在左手上的牌总是已经排序好的。**

```pascal
INSERTION-SORT
for j = 2 to A.length
    key = A[j]
    // Insert A[j] into the sorted sequence A[1...j - 1].
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

#### 循环不变式的正确性
下图表面对于A = [5, 2, 4, 6, 1, 3]，插入排序算法如何工作。下标j指出正在被插入到手中的“当前牌”。在for循环的每次迭代的开始，包含元素A[i..j-1]的子数组构成了当前排序好的左手牌，剩余子数组A[j+1..n]对应桌子上的牌堆。  
元素A[1..j-1]就是原来在位置1到j-1的元素，但现在已经按序排列。A[1..j-1]的这些性质称为循环不变式。
![image](https://note.youdao.com/yws/res/4994/8E6EE2C766D649E4917CAA3BFC1C90CD)
循环不变式主要用于帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：
+ **初始化** 循环的第一次迭代之前，它为真
+ **保持** 如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真
+ **终止** 在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

当前两套性质成立时，在循环的每次迭代之前循环不变式为真。为了证明循环不变式在每次迭代之前保持为真，可以使用不同于循环不变式本身的其他已证实的事实。这类似于数学归纳法，为了证明某条性质成立，需要证明一个**基本情况**和一个**归纳步**。这里的**基本情况**为证明第一次迭代之前不变式成立，**归纳步**为证明从一次迭代到下一次迭代不变式成立。

终止性不同于数学归纳法，在归纳法中，归纳步是无限使用的。而在算法中，当循环终止时，则会停止“归纳”。

#### 在插入排序中的循环不变式
+ **初始化** 首先证明在第一次循环迭代之前（当j=2时），循环不变式成立。子数组A[1..j-1]仅由单个元素A[1]构成，实际上就是A[1]中原来的元素。而且该数组是排序好的。这表明第一次循环迭代之前循环不变式成立。
+ **保持** 证明每次迭代都保持循环不变式。在循环中，当A[j]找到适当位置时将会插入，此时子数组A[1..j]由原来在A[1..j]中的元素组成，并且已经按顺序排列。所以对for循环的下一次迭代增加j将保持循环不变式。
+ **终止** 导致for循环终止的条件是 j > A.length。因为每次循环迭代j增加1，那么必定有 j = A.length + 1。在循环不变式的表述中将j用n + 1代替，我们有：子数组A[1..n]由原来在A[1..n]中的元素组成，但已经按顺序排列。即子数组A[1..n]就是整个数组，并且整个数组已排序。因此算法正确。

#### 插排算法的分析  
过程INSERTION-SORT需要的时间依赖于输入。并且依据数组已被排序的程度，INSERTION-SORT可能需要不同数量级的事件来排序两个具有相同规模的输入序列。

首先给出过程INSERTION-SORT中，每条语句的执行时间和执行次数：
| INSERTION-SORT(A)          | 代价  | 次数                    |
| -------------------------- | ----- | ----------------------- |
| for j = 2 to A.length      | $c_1$ | n                       |
| key = A[j]                 | $c_2$ | n - 1                   |
| i = j - 1                  | $c_3$ | n - 1                   |
| while i > 0 and A[i] > key | $c_4$ | $\sum^n_{j=2}(t_j)$     |
| A[i + 1] = A[i]            | $c_5$ | $\sum^n_{j=2}(t_j - 1)$ |
| i = i - 1                  | $c_6$ | $\sum^n_{j=2}(t_j - 1)$ |
| A[i + 1] = key             | $c_7$ | n - 1                   |
该算法的运行时间是执行每条语句的运行时间之和：
$T(n) = c_1n + c_2(n-1) + c_3(n - 1) + c_4\sum^n_{j=2}t_j + c_5\sum^n_{j=2}(t_j - 1) + c_6\sum^n_{j=2}(t_j - 1) + c_7(n-1)$

在INSERTION-SORT中，若输入数组已排好序，则出现最佳情况，有$t_j = 1$，则该最佳情况的运行时间为：
$T(n) = c_1n + c_2(n-1) + c_3(n - 1) + c_4(n-1) + c_7(n-1) = (c_1+c_2+c_3+c_4+c_8)n - (c_2+c_4+c_5+c_8)$
于是可以将这个运行时间表示为$an+b$，其中常量a和b依赖于语句的代价$c_i$。因此，它是n的**线性函数**。

在INSERTION-SORT中，若输入数组已反向排序，则会出现最坏情况，我们必须将每个元素A[j]与整个个已排序子数组A[1..j-1]中的每个元素进行比较，有$t_j=j$，则该最坏情况的运行时间为：
$$T(n) = c_1n+c_2(n-1)+c_3(n-1)+c4(\frac{n(n+1)}{2}-1)+c_5(\frac{n(n-1)}{2})+c_6(\frac{n(n-1)}{2})+c_7(n-1)$$
$$=(\frac{c_4 + c_5+c_6}{2})n^2+(c_1+c_2+c_3 + \frac{c_4-c_5-c_6}{2} + c_7)n -(c_2+c_3+c_4+c_7)$$
于是可以将这个运行时间表示为$an^2+bn+c$，其中常量a、b和c依赖于语句的代价$c_i$。因此，它是n的**二次函数**。

研究算法时，往往集中于只求**最坏情况运行时间**：
+ 一个算法的最坏情况运行时间给出了任何输入的运行时间的上限。
+ 对于某些算法，最坏情况经常出现。
+ 
## 归并排序
#### 分治法
许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归调用自身以解决紧密相关的若干子问题。这些算法典型地遵循**分治法**的思想:将原问题分解成几个规模较小但类似于原问题的子问题。递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

分治模式在每层递归时都有三个步骤：
+ 分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。
+ 递归解决子问题，当子问题规模足够小时，直接求解。
+ 合并这些子问题的解成原问题的解。

归并排序算法完全遵循分治模式。直观上其操作如下：
+ **分解** 分解待排序的n个元素的序列成各具n/2个元素的两个子序列
+ **解决** 使用归并排序递归地排序两个子序列
+ **合并** 合并两个已排序的子序列以禅城已排序的答案。

#### 算法步骤
扑克牌例子：
假设桌上有两堆牌面朝上的牌，每堆都已排序，最小的牌在顶部。
希望的结果是把这两堆牌合并成单一的排好序的输出堆，牌面朝下地放在桌上。
基本步骤为： 在牌面朝上的两堆牌的顶上两张牌选取较小的一张，将该牌从堆中移出，牌面朝下放入输出堆中。重复这个步骤，直到某个输入堆为空，这时只要将剩余的另一个输入堆放到输出堆。

#### 实现
```cpp
void MERGE(A, p, q, r) 
{
    // p、q、r是数组下标，满足p<=q<r。数组A[p..q]和A[q+1..r]都已排好序。
    int len1 = q - p + 1;
    int len2 = r - q;
    int* L = new int[len1 + 1];
    int* R = new int[len2 + 1];
    int i, j;
    for (i = 0; i < len1; i++) 
    {
        L[i] = A[p + i - 1];
    }
    for (j = 0; j < len2; j++)
    {
        R[i] = A[q + j];
    }
    L[len1 + 1] = INT_MAX;
    R[len2 + 1] = INT_MAX;
    i = 0;
    j = 0;
    // 循环不变式证明处
    for (int k = p; k < r; k ++)
    {
        if (L[i] <= R[j]) 
        {
            A[k] = L[i];
            i ++;
        }
        else 
        {
            A[k] = R[j];
            j ++;
        }
    }
}
```
可以把过程MERGE作为归并算法的一个子程序来用。下面的过程MERGE-SORT(A, p, r)排序子数组A[p..r]中的元素。若p>=r，则该子数组最多有一个元素，所以已排好序。否则，分解步骤简单地计算一个下标q，将A[p..r]分成两个子数组A[p..q]和A[q+1..r]，两者都包含n/2个元素：
```cpp
void MERGE_SORT(A, p, r)
{
    if (p < r) 
    {
        q = floor((p+r)/2);
        MERGE_SORT(A, p, q);
        MERGE_SORT(A, q+1, r);
        MERGE(A, p, q, r);
    }
}
```

#### 在归并排序中的循环不变式
+ **初始化** 循环的第一次迭代前，有k = p，所以子数组A[p..k - 1]为空。这个空的子数组包含L和R的k-p=0个最小元素，又因为i=j=0所以L[i]和R[j]都是各自所在数组中未被复制到数组A的最小元素。
+ **保持** 为了理解每次迭代都维持循环不变式，首先假设L[i]<=R[j]。这时，L[i]是未被复制回数组A的最小元素。因为A[p..k-1]包含k-p个最小元素，所以将L[i]复制到A[k]之后，子数组A[p..k]将包含k-p+1个最小元素。增加k的值和i的值，为下次迭代重新建立循环不变式。
+ **终止** 终止时，k=r+1。根据循环不变式，子数组A[p..k-1]就是A[p..r]按从小到大的顺序排列好L和R中的所有元素。

#### 归并排序时间分析
当一个算法包含对其自身的递归调用时，往往可以用递归方程或递归式来描述其运行时间，该方程根据在较小输入上的运行时间来描述在规模为n的问题上的总运行时间。  
分治算法运行时间的递归式来自基本模式的三个步骤。假设$T(n)$是规模为n的一个问题的运行时间。若问题的规模足够小，则直接求解需要常量时间$c$，将其写作$O(1)$。假设把原问题分解成$a$个子问题，每个子问题的规模是原问题的$1/b$（对于归并排序，$a$和$b$都是$2$）。为了求解一个规模为$n/b$的子问题，需要$T(n/b)$的时间，所以需要$aT(n/b)$的时间来求解$a$个问题，如果分解问题成子问题需要时间$D(n)$，合并子问题需要时间$C(n)$，那么得到递归式：
```math
T(n) = \begin{cases}
c, & 若n = 1 \\
2T(n/2) + cn， & 若n > 1
\end{cases}
```
其中常量c代表求解规模为1的问题所需的时间以及在分解步骤与合并步骤处理每个数组元素所需的时间。
下图展示了如何求解上面的递归式：

![image](https://note.youdao.com/yws/res/5012/15DC4B7F247943778EFFC18191D39736)

假设n刚好是2的幂。图的(a)部分展示了$T(n)$，它在(b)部分被扩展成一棵描绘递归式的等价树。项cn是树根（在递归的顶层消耗的代价），根的两棵子树是两个较小的递归式$T(n/2)$。(c)部分图示了通过扩展$T(n/2)$再推进一步的过程。在第二层递归中，两个子节点中每个消耗的代价都是$cn/2$。我们通过将其分解知道问题规模下降到1。每个子问题只要消耗代价c。(d)部分图示了结果递归树。

对递归式$T(n)=2T(n/2)+cn$，如何构造一棵递归树。(a)部分图示$T(n)$，它在(b)~(d)部分被逐步扩展成递归树。在(d)部分，完全扩展的递归树具有$lgn+1$层，每一层将消耗$cn$的代价。所以总代价为$cnlgn+cn$即$O(nlgn)$

> 注：算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。
如果采用二分法,那么就会以2为底数,三分法就会以3为底数,其他亦然，所以全部写成$lgn$。