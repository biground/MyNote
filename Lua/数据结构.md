# 数组
可以使用任何数值作为数组的起始索引(包括负数)

**在Lua中一般以1作为数组的起始索引**

# 矩阵和多维数组

# 链表

# 队列

# 反向表

# 图

# 集合与包
包被称为多重集合，与普通集合的不同之处在于其中的元素可以出现多次。

# 字符串缓冲区
假设有一段逐行地读取一个文件的程序，如：
```lua
local buff = ""
for line in io.lines() do
    buff = buff .. line .. '\n'
end
```
这段代码虽然能够正常工作，但实际上在处理大文件时可能导致巨大的性能开销。

假设文件每行有20个字节，在读了2500行之后，buff就会变成一个50KB大小的字符串。在Lua语言中进行字符串链接时，会创建一个50020字节的新字符串，然后从buff中赋值50000字节到新的字符串中。这样，对于后续的每一行，Lua都要移动大概50KB并且还会不断增长的内存。在读了100行(进2KB)后，Lua就已经移动了至少5MB的内存。当完成一个350KB的读取后，它至少移动了50GB的数据。

这个问题不是Lua特有的，在其他语言中，只要字符串是不可变值，就会出现类似的问题。

在Lua中，可以先用一个表当做字符串缓冲区，最后使用table.concat，这个函数会将指定列表中的所有字符串连接起来并返回连接后的结果：
```lua
local t = {}
for line in io.lines() do
    t[#t + 1] = line
end
t[#t + 1] = ""  -- 为字符串增加最后一个换行符，因为concat的第二个参数只会在两个字符串中间插入
local s = table.concat(t, "\n")
```
